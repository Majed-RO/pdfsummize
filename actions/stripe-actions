'use server';
import Stripe from 'stripe';

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY);

export async function createCheckoutSession(customerId) {
	try {
		// Get customerId from the form data or other context
		// const customerId = formData.get('customerId');

		const session = await stripe.checkout.sessions.create({
			mode: 'subscription',
			payment_method_types: ['card'],
			line_items: [
				{
					price: 'price_123...', // Your Price ID
					quantity: 1
				}
			],
			customer: customerId,
			success_url: `${process.env.NEXT_PUBLIC_BASE_URL}/success?session_id=${session.id}`,
			cancel_url: `${process.env.NEXT_PUBLIC_BASE_URL}/`
		});

		return { sessionId: session.id };
	} catch (error) {
		return { error: error.message };
	}
}

/* 
Call the Server Action from a Client Component: In your client-side component, you can call this createCheckoutSession function. Since Server Actions can be called from client components, the flow is much cleaner.

JavaScript

// components/CheckoutButton.js
'use client';

import React from 'react';
import { loadStripe } from '@stripe/stripe-js';
import { createCheckoutSession } from './actions'; // Import the server action

const stripePromise = loadStripe(process.env.NEXT_PUBLIC_STRIPE_PUBLIC_KEY);

export default function CheckoutButton({ customerId }) {
    const handleClick = async () => {
        const formData = new FormData();
        formData.append('customerId', customerId);

        const { sessionId, error } = await createCheckoutSession(formData);

        if (error) {
            console.error(error);
            return;
        }

        const stripe = await stripePromise;
        const { error: redirectToError } = await stripe.redirectToCheckout({
            sessionId,
        });

        if (redirectToError) {
            console.error(redirectToError);
        }
    };

    return (
        <button onClick={handleClick}>
            Subscribe with Server Action
        </button>
    );
}
*/
